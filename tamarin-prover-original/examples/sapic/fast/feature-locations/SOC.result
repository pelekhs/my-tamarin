maude tool: 'maude'
 checking version: 2.6. OK.
 checking installation: OK.

theory Test begin

// Function signature and definition of the equational theory E

functions: adec/2, aenc/2, check_rep/2, fst/1, get_rep/1, list/2, pair/2,
           pk/1, prog/2, rep/2 [private], sdec/2, senc/2, snd/1
equations:
    adec(aenc(x.1, pk(x.2)), x.2) = x.1,
    check_rep(rep(m, loc), loc) = m,
    fst(<x.1, x.2>) = x.1,
    get_rep(rep(m, loc)) = m,
    sdec(senc(x.1, x.2), x.2) = x.1,
    snd(<x.1, x.2>) = x.2

rule (modulo E) function_rep:
   [ In( <x1, x2> ) ] --[ Pred_pred_rep( x1, x2 ) ]-> [ Out( rep(x1, x2) ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Init:
   [ ] --[ Init( ) ]-> [ State_( ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) new_init:
   [ State_( ), Fr( init ) ] --> [ State_1( init ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Par1:
   [ State_1( init ) ] --> [ State_11( init ), State_12( init ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Rep_011:
   [ State_11( init ) ] --> [ !Semistate_111( init ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Rep_111:
   [ !Semistate_111( init ) ] --> [ State_111( init ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) in_pkskV111:
   [ State_111( init ), In( pk(skV) ) ] --> [ State_1111( init, skV ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Rep_01111:
   [ State_1111( init, skV ) ] --> [ !Semistate_11111( init, skV ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Rep_11111:
   [ !Semistate_11111( init, skV ) ] --> [ State_11111( init, skV ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) new_shared_k11111:
   [ State_11111( init, skV ), Fr( shared_k ) ]
  -->
   [ State_111111( init, shared_k, skV ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) event_SessionPpkskV_shared_k111111:
   [ State_111111( init, shared_k, skV ) ]
  --[ Event( ), SessionP( pk(skV), shared_k ) ]->
   [ State_1111111( init, shared_k, skV ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) event_Poutput_aencshared_k_pkskV_repaencshared_k_pkskV_loc_pkskV__1111111:
   [ State_1111111( init, shared_k, skV ) ]
  --[
  Event( ),
  Poutput( <aenc(shared_k, pk(skV)), 
            rep(aenc(shared_k, pk(skV)), <'loc', pk(skV)>)>
  )
  ]->
   [ State_11111111( init, shared_k, skV ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) out_aencshared_k_pkskV_repaencshared_k_pkskV_loc_pkskV__11111111:
   [ State_11111111( init, shared_k, skV ) ]
  -->
   [
   State_111111111( init, shared_k, skV ),
   Out( <aenc(shared_k, pk(skV)), 
         rep(aenc(shared_k, pk(skV)), <'loc', pk(skV)>)>
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) new_storeP111111111:
   [ State_111111111( init, shared_k, skV ), Fr( storeP ) ]
  -->
   [ State_1111111111( init, shared_k, skV, storeP ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) insert_storeP_init1111111111:
   [ State_1111111111( init, shared_k, skV, storeP ) ]
  --[ Insert( storeP, init ) ]->
   [ State_11111111111( init, shared_k, skV, storeP ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Rep_011111111111:
   [ State_11111111111( init, shared_k, skV, storeP ) ]
  -->
   [ !Semistate_111111111111( init, shared_k, skV, storeP ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Rep_111111111111:
   [ !Semistate_111111111111( init, shared_k, skV, storeP ) ]
  -->
   [ State_111111111111( init, shared_k, skV, storeP ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) lock_storeP111111111111:
   [ State_111111111111( init, shared_k, skV, storeP ), Fr( ~lock8 ) ]
  --[ Lock( ~lock8, storeP ) ]->
   [ State_1111111111111( ~lock8, init, shared_k, skV, storeP ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) lookup_storeP_as_old_i_01111111111111:
   [ State_1111111111111( ~lock8, init, shared_k, skV, storeP ) ]
  --[ IsIn( storeP, old_i ) ]->
   [ State_11111111111111( ~lock8, init, old_i, shared_k, skV, storeP ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) lookup_storeP_as_old_i_11111111111111:
   [ State_1111111111111( ~lock8, init, shared_k, skV, storeP ) ]
  --[ IsNotSet( storeP ) ]->
   [ State_11111111111112( ~lock8, init, shared_k, skV, storeP ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) in_senc_ip_input_shared_k11111111111111:
   [
   State_11111111111111( ~lock8, init, old_i, shared_k, skV, storeP ),
   In( senc(<ip, 'input'>, shared_k) )
   ]
  -->
   [ State_111111111111111( ~lock8, init, ip, old_i, shared_k, skV, storeP )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) event_Poutputsenc_progip_old_i_output_shared_k111111111111111:
   [ State_111111111111111( ~lock8, init, ip, old_i, shared_k, skV, storeP )
   ]
  --[ Event( ), Poutput( senc(<prog(ip, old_i), 'output'>, shared_k) ) ]->
   [
   State_1111111111111111( ~lock8, init, ip, old_i, shared_k, skV, storeP )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) out_senc_progip_old_i_output_shared_k1111111111111111:
   [
   State_1111111111111111( ~lock8, init, ip, old_i, shared_k, skV, storeP )
   ]
  -->
   [
   State_11111111111111111( ~lock8, init, ip, old_i, shared_k, skV, storeP
   ),
   Out( senc(<prog(ip, old_i), 'output'>, shared_k) )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) insert_storeP_listip_old_i11111111111111111:
   [
   State_11111111111111111( ~lock8, init, ip, old_i, shared_k, skV, storeP )
   ]
  --[ Insert( storeP, list(ip, old_i) ) ]->
   [
   State_111111111111111111( ~lock8, init, ip, old_i, shared_k, skV, storeP
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) unlock_storeP111111111111111111:
   [
   State_111111111111111111( ~lock8, init, ip, old_i, shared_k, skV, storeP
   )
   ]
  --[ Unlock( ~lock8, storeP ) ]->
   [
   State_1111111111111111111( ~lock8, init, ip, old_i, shared_k, skV, storeP
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) Zero1111111111111111111:
   [
   State_1111111111111111111( ~lock8, init, ip, old_i, shared_k, skV, storeP
   )
   ]
  -->
   [ ]

  /* has exactly the trivial AC variant */

rule (modulo E) Zero11111111111112:
   [ State_11111111111112( ~lock8, init, shared_k, skV, storeP ) ] --> [ ]

  /* has exactly the trivial AC variant */

rule (modulo E) Rep_012:
   [ State_12( init ) ] --> [ !Semistate_121( init ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Rep_112:
   [ !Semistate_121( init ) ] --> [ State_121( init ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) new_skV121:
   [ State_121( init ), Fr( skV ) ] --> [ State_1211( init, skV ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) event_HonestPpkskV1211:
   [ State_1211( init, skV ) ]
  --[ Event( ), HonestP( pk(skV) ) ]->
   [ State_12111( init, skV ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) out_pkskV12111:
   [ State_12111( init, skV ) ]
  -->
   [ State_121111( init, skV ), Out( pk(skV) ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) in_aencshared_k_pkskV_signed_121111:
   [ State_121111( init, skV ), In( <aenc(shared_k, pk(skV)), signed> ) ]
  -->
   [ State_1211111( init, shared_k, signed, skV ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) if_eqaencshared_k_pkskV_check_repsigned_loc_pkskV__01211111:
   [ State_1211111( init, shared_k, signed, skV ) ]
  --[
  Pred_eq( aenc(shared_k, pk(skV)), check_rep(signed, <'loc', pk(skV)>) )
  ]->
   [ State_12111111( init, shared_k, signed, skV ) ]

  /*
  rule (modulo AC) if_eqaencshared_k_pkskV_check_repsigned_loc_pkskV__01211111:
     [ State_1211111( init, shared_k, signed, skV ) ]
    --[ Pred_eq( aenc(shared_k, pk(skV)), z ) ]->
     [ State_12111111( init, shared_k, signed, skV ) ]
    variants (modulo AC)
    1. signed
             = signed.6
       skV   = skV.6
       z     = check_rep(signed.6, <'loc', pk(skV.6)>)
    
    2. signed
             = rep(x.7, <'loc', pk(x.6)>)
       skV   = x.6
       z     = x.7
  */

rule (modulo E) if_eqaencshared_k_pkskV_check_repsigned_loc_pkskV__11211111:
   [ State_1211111( init, shared_k, signed, skV ) ]
  --[
  Pred_not_eq( aenc(shared_k, pk(skV)), check_rep(signed, <'loc', pk(skV)>)
  )
  ]->
   [ State_12111112( init, shared_k, signed, skV ) ]

  /*
  rule (modulo AC) if_eqaencshared_k_pkskV_check_repsigned_loc_pkskV__11211111:
     [ State_1211111( init, shared_k, signed, skV ) ]
    --[ Pred_not_eq( aenc(shared_k, pk(skV)), z ) ]->
     [ State_12111112( init, shared_k, signed, skV ) ]
    variants (modulo AC)
    1. signed
             = signed.6
       skV   = skV.6
       z     = check_rep(signed.6, <'loc', pk(skV.6)>)
    
    2. signed
             = rep(x.7, <'loc', pk(x.6)>)
       skV   = x.6
       z     = x.7
  */

rule (modulo E) event_Voutput_aencshared_k_pkskV_signed_12111111:
   [ State_12111111( init, shared_k, signed, skV ) ]
  --[ Event( ), Voutput( <aenc(shared_k, pk(skV)), signed> ) ]->
   [ State_121111111( init, shared_k, signed, skV ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) event_SessionVpkskV_shared_k121111111:
   [ State_121111111( init, shared_k, signed, skV ) ]
  --[ Event( ), SessionV( pk(skV), shared_k ) ]->
   [ State_1211111111( init, shared_k, signed, skV ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) new_storeV1211111111:
   [ State_1211111111( init, shared_k, signed, skV ), Fr( storeV ) ]
  -->
   [ State_12111111111( init, shared_k, signed, skV, storeV ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) insert_storeV_init12111111111:
   [ State_12111111111( init, shared_k, signed, skV, storeV ) ]
  --[ Insert( storeV, init ) ]->
   [ State_121111111111( init, shared_k, signed, skV, storeV ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Rep_0121111111111:
   [ State_121111111111( init, shared_k, signed, skV, storeV ) ]
  -->
   [ !Semistate_1211111111111( init, shared_k, signed, skV, storeV ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Rep_1121111111111:
   [ !Semistate_1211111111111( init, shared_k, signed, skV, storeV ) ]
  -->
   [ State_1211111111111( init, shared_k, signed, skV, storeV ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) lock_storeV1211111111111:
   [
   State_1211111111111( init, shared_k, signed, skV, storeV ), Fr( ~lock10 )
   ]
  --[ Lock( ~lock10, storeV ) ]->
   [ State_12111111111111( ~lock10, init, shared_k, signed, skV, storeV ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) lookup_storeV_as_old_i_012111111111111:
   [ State_12111111111111( ~lock10, init, shared_k, signed, skV, storeV ) ]
  --[ IsIn( storeV, old_i ) ]->
   [
   State_121111111111111( ~lock10, init, old_i, shared_k, signed, skV,
                          storeV
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) lookup_storeV_as_old_i_112111111111111:
   [ State_12111111111111( ~lock10, init, shared_k, signed, skV, storeV ) ]
  --[ IsNotSet( storeV ) ]->
   [ State_121111111111112( ~lock10, init, shared_k, signed, skV, storeV ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) new_ip121111111111111:
   [
   State_121111111111111( ~lock10, init, old_i, shared_k, signed, skV,
                          storeV
   ),
   Fr( ip )
   ]
  -->
   [
   State_1211111111111111( ~lock10, init, ip, old_i, shared_k, signed, skV,
                           storeV
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) event_Inputsencip_shared_k1211111111111111:
   [
   State_1211111111111111( ~lock10, init, ip, old_i, shared_k, signed, skV,
                           storeV
   )
   ]
  --[ Event( ), Input( senc(ip, shared_k) ) ]->
   [
   State_12111111111111111( ~lock10, init, ip, old_i, shared_k, signed, skV,
                            storeV
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) out_senc_ip_input_shared_k12111111111111111:
   [
   State_12111111111111111( ~lock10, init, ip, old_i, shared_k, signed, skV,
                            storeV
   )
   ]
  -->
   [
   State_121111111111111111( ~lock10, init, ip, old_i, shared_k, signed,
                             skV, storeV
   ),
   Out( senc(<ip, 'input'>, shared_k) )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) in_senc_progip_old_i_output_shared_k121111111111111111:
   [
   State_121111111111111111( ~lock10, init, ip, old_i, shared_k, signed,
                             skV, storeV
   ),
   In( senc(<prog(ip, old_i), 'output'>, shared_k) )
   ]
  -->
   [
   State_1211111111111111111( ~lock10, init, ip, old_i, shared_k, signed,
                              skV, storeV
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) event_Voutputsenc_progip_old_i_output_shared_k1211111111111111111:
   [
   State_1211111111111111111( ~lock10, init, ip, old_i, shared_k, signed,
                              skV, storeV
   )
   ]
  --[ Event( ), Voutput( senc(<prog(ip, old_i), 'output'>, shared_k) ) ]->
   [
   State_12111111111111111111( ~lock10, init, ip, old_i, shared_k, signed,
                               skV, storeV
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) insert_storeV_listip_old_i12111111111111111111:
   [
   State_12111111111111111111( ~lock10, init, ip, old_i, shared_k, signed,
                               skV, storeV
   )
   ]
  --[ Insert( storeV, list(ip, old_i) ) ]->
   [
   State_121111111111111111111( ~lock10, init, ip, old_i, shared_k, signed,
                                skV, storeV
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) unlock_storeV121111111111111111111:
   [
   State_121111111111111111111( ~lock10, init, ip, old_i, shared_k, signed,
                                skV, storeV
   )
   ]
  --[ Unlock( ~lock10, storeV ) ]->
   [
   State_1211111111111111111111( ~lock10, init, ip, old_i, shared_k, signed,
                                 skV, storeV
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) Zero1211111111111111111111:
   [
   State_1211111111111111111111( ~lock10, init, ip, old_i, shared_k, signed,
                                 skV, storeV
   )
   ]
  -->
   [ ]

  /* has exactly the trivial AC variant */

rule (modulo E) Zero121111111111112:
   [ State_121111111111112( ~lock10, init, shared_k, signed, skV, storeV ) ]
  -->
   [ ]

  /* has exactly the trivial AC variant */

rule (modulo E) Zero12111112:
   [ State_12111112( init, shared_k, signed, skV ) ] --> [ ]

  /* has exactly the trivial AC variant */

restriction set_in:
  "∀ x y #t3.
    (IsIn( x, y ) @ #t3) ⇒
    (∃ #t2.
      (((Insert( x, y ) @ #t2) ∧ (#t2 < #t3)) ∧
       (∀ #t1. (Delete( x ) @ #t1) ⇒ ((#t1 < #t2) ∨ (#t3 < #t1)))) ∧
      (∀ #t1 yp.
        (Insert( x, yp ) @ #t1) ⇒ (((#t1 < #t2) ∨ (#t1 = #t2)) ∨ (#t3 < #t1))))"

restriction set_notin:
  "∀ x #t3.
    (IsNotSet( x ) @ #t3) ⇒
    ((∀ #t1 y. (Insert( x, y ) @ #t1) ⇒ (#t3 < #t1)) ∨
     (∃ #t1.
       ((Delete( x ) @ #t1) ∧ (#t1 < #t3)) ∧
       (∀ #t2 y. ((Insert( x, y ) @ #t2) ∧ (#t2 < #t3)) ⇒ (#t2 < #t1))))"

restriction locking:
  "∀ l x lp #t1 #t3.
    ((Lock( l, x ) @ #t1) ∧ (Lock( lp, x ) @ #t3)) ⇒
    ((((#t1 < #t3) ∧
       (∃ #t2.
         (((((Unlock( l, x ) @ #t2) ∧ (#t1 < #t2)) ∧ (#t2 < #t3)) ∧
           (∀ #t0. (Unlock( l, x ) @ #t0) ⇒ (#t0 = #t2))) ∧
          (∀ lp.1 #t0.
            (Lock( lp.1, x ) @ #t0) ⇒ (((#t0 < #t1) ∨ (#t0 = #t1)) ∨ (#t2 < #t0)))) ∧
         (∀ lp.1 #t0.
           (Unlock( lp.1, x ) @ #t0) ⇒
           (((#t0 < #t1) ∨ (#t2 < #t0)) ∨ (#t2 = #t0))))) ∨
      (#t3 < #t1)) ∨
     (#t1 = #t3))"

restriction predicate_eq:
  "∀ #i a b. (Pred_eq( a, b ) @ #i) ⇒ (a = b)"
  // safety formula

restriction predicate_not_eq:
  "∀ #i a b. (Pred_not_eq( a, b ) @ #i) ⇒ (¬(a = b))"
  // safety formula

restriction single_session:
  "∀ #i #j. ((Init( ) @ #i) ∧ (Init( ) @ #j)) ⇒ (#i = #j)"
  // safety formula

restriction predicate1:
  "∀ #i x y.
    (Pred_not_pred_rep( x, y ) @ #i) ⇒ (¬(¬(∃ z. y = <'loc', z>)))"

restriction predicate0:
  "∀ #i x y. (Pred_pred_rep( x, y ) @ #i) ⇒ (¬(∃ z. y = <'loc', z>))"
  // safety formula

lemma secrecy [reuse]:
  all-traces
  "¬(∃ pka k #t1 #t2. (SessionV( pka, k ) @ #t1) ∧ (!KU( k ) @ #t2))"
/*
guarded formula characterizing all counter-examples:
"∃ pka k #t1 #t2. (SessionV( pka, k ) @ #t1) ∧ (!KU( k ) @ #t2)"
*/
simplify
solve( State_121111111( init, k, signed, skV ) ▶₀ #t1 )
  case event_Voutput_aencshared_k_pkskV_signed_12111111
  solve( !KU( ~n.1 ) @ #t2 )
    case out_aencshared_k_pkskV_repaencshared_k_pkskV_loc_pkskV__11111111_case_1
    by solve( !KU( ~n.2 ) @ #vk.4 )
  next
    case out_aencshared_k_pkskV_repaencshared_k_pkskV_loc_pkskV__11111111_case_2
    by solve( !KU( ~n.2 ) @ #vk.4 )
  qed
qed

lemma Input [use_induction, reuse]:
  all-traces
  "∀ #t1 ip shared_key.
    (Input( senc(ip, shared_key) ) @ #t1) ⇒
    (∃ #t2 pk. (SessionV( pk, shared_key ) @ #t2) ∧ (#t2 < #t1))"
/*
guarded formula characterizing all counter-examples:
"∃ #t1 ip shared_key.
  (Input( senc(ip, shared_key) ) @ #t1)
 ∧
  ∀ #t2 pk. (SessionV( pk, shared_key ) @ #t2) ⇒ ¬(#t2 < #t1)"
*/
induction
  case empty_trace
  by contradiction /* from formulas */
next
  case non_empty_trace
  simplify
  solve( (∀ #t1 ip shared_key.
           (Input( senc(ip, shared_key) ) @ #t1)
          ⇒
           (last(#t1)) ∨
           (∃ #t2 pk.
             (SessionV( pk, shared_key ) @ #t2) ∧ (¬(last(#t2))) ∧ (#t2 < #t1)))  ∥
         (∃ x y #t3.
           (IsIn( x, y ) @ #t3)
          ∧
           (¬(last(#t3))) ∧
           (∀ #t2.
             (Insert( x, y ) @ #t2)
            ⇒
             (last(#t2)) ∨
             (#t2 = #t3) ∨
             (#t3 < #t2) ∨
             (∃ #t1.
               (Delete( x ) @ #t1)
              ∧
               (¬(last(#t1))) ∧
               ((#t1 = #t2) ∨ (#t2 < #t1)) ∧
               ((#t3 = #t1) ∨ (#t1 < #t3))) ∨
             (∃ #t1 yp.
               (Insert( x, yp ) @ #t1)
              ∧
               (¬(last(#t1))) ∧
               ((#t1 = #t2) ∨ (#t2 < #t1)) ∧
               (¬(#t1 = #t2)) ∧
               ((#t3 = #t1) ∨ (#t1 < #t3)))))  ∥
         (∃ x #t3.
           (IsNotSet( x ) @ #t3)
          ∧
           (¬(last(#t3))) ∧
           (∃ #t1 y.
             (Insert( x, y ) @ #t1) ∧ (¬(last(#t1))) ∧ ((#t3 = #t1) ∨ (#t1 < #t3))) ∧
           (∀ #t1.
             (Delete( x ) @ #t1)
            ⇒
             (last(#t1)) ∨
             (#t1 = #t3) ∨
             (#t3 < #t1) ∨
             (∃ #t2 y.
               (Insert( x, y ) @ #t2)
              ∧
               (¬(last(#t2))) ∧ (#t2 < #t3) ∧ ((#t2 = #t1) ∨ (#t1 < #t2)))))  ∥
         (∃ l x lp #t1 #t3.
           (Lock( l, x ) @ #t1) ∧ (Lock( lp, x ) @ #t3)
          ∧
           (¬(last(#t3))) ∧
           (¬(last(#t1))) ∧
           ((#t1 = #t3) ∨
            (#t3 < #t1) ∨
            (∀ #t2.
              (Unlock( l, x ) @ #t2)
             ⇒
              (last(#t2)) ∨
              (#t1 = #t2) ∨
              (#t2 < #t1) ∨
              (#t2 = #t3) ∨
              (#t3 < #t2) ∨
              (∃ #t0. (Unlock( l, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
              (∃ lp.1 #t0.
                (Lock( lp.1, x ) @ #t0)
               ∧
                (¬(last(#t0))) ∧
                ((#t0 = #t1) ∨ (#t1 < #t0)) ∧
                (¬(#t0 = #t1)) ∧
                ((#t2 = #t0) ∨ (#t0 < #t2))) ∨
              (∃ lp.1 #t0.
                (Unlock( lp.1, x ) @ #t0)
               ∧
                (¬(last(#t0))) ∧
                ((#t0 = #t1) ∨ (#t1 < #t0)) ∧
                ((#t2 = #t0) ∨ (#t0 < #t2)) ∧
                (¬(#t2 = #t0))))) ∧
           ((#t3 = #t1) ∨ (#t1 < #t3)) ∧
           (¬(#t1 = #t3)))  ∥
         (∃ #i x y.
           (Pred_not_pred_rep( x, y ) @ #i)
          ∧
           (¬(last(#i))) ∧ (∀ z. (y = <'loc', z>) ⇒ ⊥)) )
    case case_1
    solve( (last(#t1))  ∥
           (∃ #t2 pk.
             (SessionV( pk, shared_key ) @ #t2) ∧ (¬(last(#t2))) ∧ (#t2 < #t1)) )
      case case_1
      solve( State_1211111111111111( ~lock10, init, ip, old_i, shared_key,
                                     signed, skV, storeV
             ) ▶₀ #t1 )
        case new_ip121111111111111
        by contradiction /* from formulas */
      qed
    next
      case case_2
      by contradiction /* from formulas */
    qed
  next
    case case_2
    solve( (∃ #t1.
             (Delete( x ) @ #t1)
            ∧
             (¬(last(#t1))) ∧
             ((#t1 = #t2) ∨ (#t2 < #t1)) ∧
             ((#t3 = #t1) ∨ (#t1 < #t3)))  ∥
           (∃ #t1 yp.
             (Insert( x, yp ) @ #t1)
            ∧
             (¬(last(#t1))) ∧
             ((#t1 = #t2) ∨ (#t2 < #t1)) ∧
             (¬(#t1 = #t2)) ∧
             ((#t3 = #t1) ∨ (#t1 < #t3))) )
      case case_1
      solve( (#t1.1 = #t2)  ∥ (#t2 < #t1.1) )
        case case_1
        by contradiction /* from formulas */
      next
        case case_2
        by contradiction /* from formulas */
      qed
    next
      case case_2
      solve( (#t1.1 = #t2)  ∥ (#t2 < #t1.1) )
        case case_1
        by contradiction /* from formulas */
      next
        case case_2
        by contradiction /* from formulas */
      qed
    qed
  next
    case case_3
    solve( (#t3 = #t1.1)  ∥ (#t1.1 < #t3) )
      case case_1
      solve( (∀ #t1 y. (Insert( x, y ) @ #t1) ⇒ #t3 < #t1)  ∥
             (∃ #t1.
               (Delete( x ) @ #t1)
              ∧
               (#t1 < #t3) ∧
               (∀ #t2 y. (Insert( x, y ) @ #t2) ⇒ (¬(#t2 < #t3)) ∨ (#t2 < #t1))) )
        case case_1
        by contradiction /* cyclic */
      next
        case case_2
        by contradiction /* from formulas */
      qed
    next
      case case_2
      solve( (∀ #t1 y. (Insert( x, y ) @ #t1) ⇒ #t3 < #t1)  ∥
             (∃ #t1.
               (Delete( x ) @ #t1)
              ∧
               (#t1 < #t3) ∧
               (∀ #t2 y. (Insert( x, y ) @ #t2) ⇒ (¬(#t2 < #t3)) ∨ (#t2 < #t1))) )
        case case_1
        by contradiction /* cyclic */
      next
        case case_2
        by contradiction /* from formulas */
      qed
    qed
  next
    case case_4
    solve( (#t1.1 = #t3)  ∥ (#t3 < #t1.1)  ∥
           (∀ #t2.
             (Unlock( l, x ) @ #t2)
            ⇒
             (last(#t2)) ∨
             (#t1.1 = #t2) ∨
             (#t2 < #t1.1) ∨
             (#t2 = #t3) ∨
             (#t3 < #t2) ∨
             (∃ #t0. (Unlock( l, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2))) ∨
             (∃ lp #t0.
               (Lock( lp, x ) @ #t0)
              ∧
               (¬(last(#t0))) ∧
               ((#t0 = #t1.1) ∨ (#t1.1 < #t0)) ∧
               (¬(#t0 = #t1.1)) ∧
               ((#t2 = #t0) ∨ (#t0 < #t2))) ∨
             (∃ lp #t0.
               (Unlock( lp, x ) @ #t0)
              ∧
               (¬(last(#t0))) ∧
               ((#t0 = #t1.1) ∨ (#t1.1 < #t0)) ∧
               ((#t2 = #t0) ∨ (#t0 < #t2)) ∧
               (¬(#t2 = #t0)))) )
      case case_1
      by contradiction /* from formulas */
    next
      case case_2
      by contradiction /* from formulas */
    next
      case case_3
      solve( (#t3 = #t1.1)  ∥ (#t1.1 < #t3) )
        case case_1
        by contradiction /* from formulas */
      next
        case case_2
        solve( (∃ #t0.
                 (Unlock( l, x ) @ #t0) ∧ (¬(last(#t0))) ∧ (¬(#t0 = #t2)))  ∥
               (∃ lp #t0.
                 (Lock( lp, x ) @ #t0)
                ∧
                 (¬(last(#t0))) ∧
                 ((#t0 = #t1.1) ∨ (#t1.1 < #t0)) ∧
                 (¬(#t0 = #t1.1)) ∧
                 ((#t2 = #t0) ∨ (#t0 < #t2)))  ∥
               (∃ lp #t0.
                 (Unlock( lp, x ) @ #t0)
                ∧
                 (¬(last(#t0))) ∧
                 ((#t0 = #t1.1) ∨ (#t1.1 < #t0)) ∧
                 ((#t2 = #t0) ∨ (#t0 < #t2)) ∧
                 (¬(#t2 = #t0))) )
          case case_1
          by contradiction /* from formulas */
        next
          case case_2
          solve( (#t0 = #t1.1)  ∥ (#t1.1 < #t0) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        next
          case case_3
          solve( (#t0 = #t1.1)  ∥ (#t1.1 < #t0) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            solve( (#t2 = #t0)  ∥ (#t0 < #t2) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            qed
          qed
        qed
      qed
    qed
  next
    case case_5
    by contradiction /* from formulas */
  qed
qed

lemma secrecy_computes2 [reuse]:
  all-traces
  "¬(∃ ip k #t2 #t3. (Input( senc(ip, k) ) @ #t2) ∧ (!KU( ip ) @ #t3))"
/*
guarded formula characterizing all counter-examples:
"∃ ip k #t2 #t3. (Input( senc(ip, k) ) @ #t2) ∧ (!KU( ip ) @ #t3)"
*/
simplify
solve( State_1211111111111111( ~lock10, init, ip, old_i, k, signed, skV,
                               storeV
       ) ▶₀ #t2 )
  case new_ip121111111111111
  solve( (#vr.5 < #t2.3)  ∥ (#vr.5 = #t2.3) )
    case case_1
    solve( State_121111111( init, ~n.2, signed, skV ) ▶₀ #t2.1 )
      case event_Voutput_aencshared_k_pkskV_signed_12111111
      solve( State_121111111( init, ~n.2, signed, skV ) ▶₀ #t2.2 )
        case event_Voutput_aencshared_k_pkskV_signed_12111111
        solve( !KU( ~n.1 ) @ #t3 )
          case out_senc_ip_input_shared_k12111111111111111
          by contradiction /* from formulas */
        qed
      qed
    qed
  next
    case case_2
    solve( State_121111111( init, ~n.2, signed, skV ) ▶₀ #t2.1 )
      case event_Voutput_aencshared_k_pkskV_signed_12111111
      solve( State_121111111( init, ~n.2, signed, skV ) ▶₀ #t2.2 )
        case event_Voutput_aencshared_k_pkskV_signed_12111111
        solve( !KU( ~n.1 ) @ #t3 )
          case out_senc_ip_input_shared_k12111111111111111
          by contradiction /* from formulas */
        qed
      qed
    qed
  qed
qed

lemma secrecy_computes3 [reuse]:
  all-traces
  "¬(∃ ip k old_i #t2 #t3.
      (Input( senc(ip, k) ) @ #t2) ∧ (!KU( prog(ip, old_i) ) @ #t3))"
/*
guarded formula characterizing all counter-examples:
"∃ ip k old_i #t2 #t3.
  (Input( senc(ip, k) ) @ #t2) ∧ (!KU( prog(ip, old_i) ) @ #t3)"
*/
simplify
solve( State_1211111111111111( ~lock10, init, ip, old_i, k, signed, skV,
                               storeV
       ) ▶₀ #t2 )
  case new_ip121111111111111
  solve( (#vr.5 < #t2.3)  ∥ (#vr.5 = #t2.3) )
    case case_1
    solve( State_121111111( init, ~n.2, signed, skV ) ▶₀ #t2.1 )
      case event_Voutput_aencshared_k_pkskV_signed_12111111
      solve( State_121111111( init, ~n.2, signed, skV ) ▶₀ #t2.2 )
        case event_Voutput_aencshared_k_pkskV_signed_12111111
        solve( !KU( prog(~n.1, old_i.1) ) @ #t3 )
          case cprog
          by contradiction /* from formulas */
        next
          case out_senc_progip_old_i_output_shared_k1111111111111111
          solve( (#vr.37 < #t2.3)  ∥ (#vr.37 = #t2.3) )
            case case_1
            solve( Insert( ~n.4, old_i ) @ #t2.2 )
              case insert_storeP_init1111111111
              by solve( State_1111111111( old_i, shared_k, skV, ~n.4 ) ▶₀ #t2.2 )
            next
              case insert_storeP_listip_old_i11111111111111111
              by solve( State_11111111111111111( ~lock8, init, ip, old_i, shared_k,
                                                 skV, ~n.4
                        ) ▶₀ #t2.2 )
            next
              case insert_storeV_init12111111111
              solve( State_12111111111( old_i, shared_k, signed, skV, ~n.4 ) ▶₀ #t2.2 )
                case new_storeV1211111111
                by contradiction /* cyclic */
              qed
            next
              case insert_storeV_listip_old_i12111111111111111111
              solve( State_12111111111111111111( ~lock10.1, init, ip, old_i, shared_k,
                                                 signed, skV, ~n.4
                     ) ▶₀ #t2.2 )
                case event_Voutputsenc_progip_old_i_output_shared_k1211111111111111111
                solve( ((#vr.2 < #vr.53) ∧
                        (∃ #t2.
                          (Unlock( ~lock10, ~n.5 ) @ #t2)
                         ∧
                          (#vr.2 < #t2) ∧
                          (#t2 < #vr.53) ∧
                          (∀ #t0. (Unlock( ~lock10, ~n.5 ) @ #t0) ⇒ #t0 = #t2) ∧
                          (∀ lp #t0.
                            (Lock( lp, ~n.5 ) @ #t0) ⇒ (#t0 < #vr.2) ∨ (#t0 = #vr.2) ∨ (#t2 < #t0)) ∧
                          (∀ lp #t0.
                            (Unlock( lp, ~n.5 ) @ #t0)
                           ⇒
                            (#t0 < #vr.2) ∨ (#t2 < #t0) ∨ (#t2 = #t0))))  ∥
                       (#vr.53 < #vr.2)  ∥ (#vr.2 = #vr.53) )
                  case case_1
                  solve( (#vr.5 < #t2.6)  ∥ (#vr.5 = #t2.6) )
                    case case_1
                    solve( State_121111111( init, ~n.3, signed, skV ) ▶₀ #t2.3 )
                      case event_Voutput_aencshared_k_pkskV_signed_12111111
                      solve( Unlock( ~lock10, ~n.5 ) @ #t2.3 )
                        case unlock_storeP111111111111111111
                        by solve( State_111111111111111111( ~lock10, init, ip, old_i.2, shared_k,
                                                            skV, ~n.5
                                  ) ▶₀ #t2.3 )
                      next
                        case unlock_storeV121111111111111111111
                        solve( State_121111111111111111111( ~lock10, init, ip, old_i.2, shared_k,
                                                            signed, skV, ~n.5
                               ) ▶₀ #t2.3 )
                          case insert_storeV_listip_old_i12111111111111111111
                          by contradiction /* cyclic */
                        qed
                      qed
                    qed
                  next
                    case case_2
                    solve( State_121111111( init, ~n.3, signed, skV ) ▶₀ #t2.3 )
                      case event_Voutput_aencshared_k_pkskV_signed_12111111
                      solve( Unlock( ~lock10, ~n.5 ) @ #t2.3 )
                        case unlock_storeP111111111111111111
                        by solve( State_111111111111111111( ~lock10, init, ip, old_i.2, shared_k,
                                                            skV, ~n.5
                                  ) ▶₀ #t2.3 )
                      next
                        case unlock_storeV121111111111111111111
                        solve( State_121111111111111111111( ~lock10, init, ip, old_i.2, shared_k,
                                                            signed, skV, ~n.5
                               ) ▶₀ #t2.3 )
                          case insert_storeV_listip_old_i12111111111111111111
                          by contradiction /* cyclic */
                        qed
                      qed
                    qed
                  qed
                next
                  case case_2
                  solve( (#vr.5 < #t2.5)  ∥ (#vr.5 = #t2.5) )
                    case case_1
                    solve( State_121111111( init, ~n.3, signed, skV ) ▶₀ #t2.3 )
                      case event_Voutput_aencshared_k_pkskV_signed_12111111
                      solve( Unlock( ~lock10.1, ~n.5 ) @ #t2.5 )
                        case unlock_storeP111111111111111111
                        by solve( State_111111111111111111( ~lock10.1, init, ip, old_i.2,
                                                            shared_k, skV, ~n.5
                                  ) ▶₀ #t2.3 )
                      next
                        case unlock_storeV121111111111111111111
                        solve( State_121111111111111111111( ~lock10.1, init, ip, old_i.2,
                                                            shared_k, signed, skV, ~n.5
                               ) ▶₀ #t2.3 )
                          case insert_storeV_listip_old_i12111111111111111111
                          solve( (#vr.5 < #t2.7)  ∥ (#vr.5 = #t2.7) )
                            case case_1
                            solve( (#t2.6 < #t2.7)  ∥ (#t2.6 = #t2.7) )
                              case case_1
                              by contradiction /* from formulas */
                            next
                              case case_2
                              solve( State_121111111( init, ~n.3, signed, skV ) ▶₀ #t2.4 )
                                case event_Voutput_aencshared_k_pkskV_signed_12111111
                                solve( !KU( ~n.6 ) @ #vk.4 )
                                  case out_aencshared_k_pkskV_repaencshared_k_pkskV_loc_pkskV__11111111_case_1
                                  solve( !KU( senc(<~n.1, 'input'>, ~n.6) ) @ #vk.5 )
                                    case csenc
                                    by contradiction /* from formulas */
                                  next
                                    case out_senc_ip_input_shared_k12111111111111111
                                    by contradiction /* from formulas */
                                  qed
                                next
                                  case out_aencshared_k_pkskV_repaencshared_k_pkskV_loc_pkskV__11111111_case_2
                                  solve( !KU( senc(<~n.1, 'input'>, ~n.6) ) @ #vk.5 )
                                    case csenc
                                    by contradiction /* from formulas */
                                  next
                                    case out_senc_ip_input_shared_k12111111111111111
                                    by contradiction /* from formulas */
                                  qed
                                qed
                              qed
                            qed
                          next
                            case case_2
                            by contradiction /* from formulas */
                          qed
                        qed
                      qed
                    qed
                  next
                    case case_2
                    solve( State_121111111( init, ~n.3, signed, skV ) ▶₀ #t2.3 )
                      case event_Voutput_aencshared_k_pkskV_signed_12111111
                      solve( Unlock( ~lock10.1, ~n.5 ) @ #t2.5 )
                        case unlock_storeP111111111111111111
                        by solve( State_111111111111111111( ~lock10.1, init, ip, old_i.2,
                                                            shared_k, skV, ~n.5
                                  ) ▶₀ #t2.4 )
                      next
                        case unlock_storeV121111111111111111111
                        solve( State_121111111111111111111( ~lock10.1, init, ip, old_i.2,
                                                            shared_k, signed, skV, ~n.5
                               ) ▶₀ #t2.4 )
                          case insert_storeV_listip_old_i12111111111111111111
                          solve( (#t2.3 < #t2.7)  ∥ (#t2.3 = #t2.7) )
                            case case_1
                            by contradiction /* from formulas */
                          next
                            case case_2
                            solve( State_121111111( init, ~n.3, signed, skV ) ▶₀ #t2.5 )
                              case event_Voutput_aencshared_k_pkskV_signed_12111111
                              solve( !KU( ~n.6 ) @ #vk.4 )
                                case out_aencshared_k_pkskV_repaencshared_k_pkskV_loc_pkskV__11111111_case_1
                                solve( !KU( senc(<~n.1, 'input'>, ~n.6) ) @ #vk.5 )
                                  case csenc
                                  by contradiction /* from formulas */
                                next
                                  case out_senc_ip_input_shared_k12111111111111111
                                  by contradiction /* from formulas */
                                qed
                              next
                                case out_aencshared_k_pkskV_repaencshared_k_pkskV_loc_pkskV__11111111_case_2
                                solve( !KU( senc(<~n.1, 'input'>, ~n.6) ) @ #vk.5 )
                                  case csenc
                                  by contradiction /* from formulas */
                                next
                                  case out_senc_ip_input_shared_k12111111111111111
                                  by contradiction /* from formulas */
                                qed
                              qed
                            qed
                          qed
                        qed
                      qed
                    qed
                  qed
                qed
              qed
            qed
          next
            case case_2
            solve( Insert( ~n.4, old_i ) @ #t2.3 )
              case insert_storeP_init1111111111
              by solve( State_1111111111( old_i, shared_k, skV.1, ~n.4 ) ▶₀ #t2.3 )
            next
              case insert_storeP_listip_old_i11111111111111111
              by solve( State_11111111111111111( ~lock8, init, ip, old_i, shared_k,
                                                 skV.1, ~n.4
                        ) ▶₀ #t2.3 )
            next
              case insert_storeV_init12111111111
              solve( State_12111111111( old_i, shared_k, signed, skV.1, ~n.4
                     ) ▶₀ #t2.3 )
                case new_storeV1211111111
                by contradiction /* cyclic */
              qed
            next
              case insert_storeV_listip_old_i12111111111111111111
              solve( State_12111111111111111111( ~lock10.1, init, ip, old_i, shared_k,
                                                 signed, skV.1, ~n.4
                     ) ▶₀ #t2.3 )
                case event_Voutputsenc_progip_old_i_output_shared_k1211111111111111111
                solve( ((#vr.2 < #vr.52) ∧
                        (∃ #t2.
                          (Unlock( ~lock10, ~n.5 ) @ #t2)
                         ∧
                          (#vr.2 < #t2) ∧
                          (#t2 < #vr.52) ∧
                          (∀ #t0. (Unlock( ~lock10, ~n.5 ) @ #t0) ⇒ #t0 = #t2) ∧
                          (∀ lp #t0.
                            (Lock( lp, ~n.5 ) @ #t0) ⇒ (#t0 < #vr.2) ∨ (#t0 = #vr.2) ∨ (#t2 < #t0)) ∧
                          (∀ lp #t0.
                            (Unlock( lp, ~n.5 ) @ #t0)
                           ⇒
                            (#t0 < #vr.2) ∨ (#t2 < #t0) ∨ (#t2 = #t0))))  ∥
                       (#vr.52 < #vr.2)  ∥ (#vr.2 = #vr.52) )
                  case case_1
                  solve( (#vr.5 < #t2.6)  ∥ (#vr.5 = #t2.6) )
                    case case_1
                    solve( State_121111111( init, ~n.3, signed, skV.1 ) ▶₀ #t2.4 )
                      case event_Voutput_aencshared_k_pkskV_signed_12111111
                      solve( Unlock( ~lock10, ~n.5 ) @ #t2.4 )
                        case unlock_storeP111111111111111111
                        by solve( State_111111111111111111( ~lock10, init, ip, old_i.2, shared_k,
                                                            skV.1, ~n.5
                                  ) ▶₀ #t2.4 )
                      next
                        case unlock_storeV121111111111111111111
                        solve( State_121111111111111111111( ~lock10, init, ip, old_i.2, shared_k,
                                                            signed, skV.1, ~n.5
                               ) ▶₀ #t2.4 )
                          case insert_storeV_listip_old_i12111111111111111111
                          by contradiction /* cyclic */
                        qed
                      qed
                    qed
                  next
                    case case_2
                    solve( State_121111111( init, ~n.3, signed, skV.1 ) ▶₀ #t2.4 )
                      case event_Voutput_aencshared_k_pkskV_signed_12111111
                      solve( Unlock( ~lock10, ~n.5 ) @ #t2.4 )
                        case unlock_storeP111111111111111111
                        by solve( State_111111111111111111( ~lock10, init, ip, old_i.2, shared_k,
                                                            skV.1, ~n.5
                                  ) ▶₀ #t2.4 )
                      next
                        case unlock_storeV121111111111111111111
                        solve( State_121111111111111111111( ~lock10, init, ip, old_i.2, shared_k,
                                                            signed, skV.1, ~n.5
                               ) ▶₀ #t2.4 )
                          case insert_storeV_listip_old_i12111111111111111111
                          by contradiction /* cyclic */
                        qed
                      qed
                    qed
                  qed
                next
                  case case_2
                  solve( (#vr.5 < #t2.5)  ∥ (#vr.5 = #t2.5) )
                    case case_1
                    solve( State_121111111( init, ~n.3, signed, skV.1 ) ▶₀ #t2.4 )
                      case event_Voutput_aencshared_k_pkskV_signed_12111111
                      solve( Unlock( ~lock10.1, ~n.5 ) @ #t2.5 )
                        case unlock_storeP111111111111111111
                        by solve( State_111111111111111111( ~lock10.1, init, ip, old_i.2,
                                                            shared_k, skV.1, ~n.5
                                  ) ▶₀ #t2.4 )
                      next
                        case unlock_storeV121111111111111111111
                        solve( State_121111111111111111111( ~lock10.1, init, ip, old_i.2,
                                                            shared_k, signed, skV.1, ~n.5
                               ) ▶₀ #t2.4 )
                          case insert_storeV_listip_old_i12111111111111111111
                          solve( (#vr.5 < #t2.7)  ∥ (#vr.5 = #t2.7) )
                            case case_1
                            solve( (#t2.6 < #t2.7)  ∥ (#t2.6 = #t2.7) )
                              case case_1
                              by contradiction /* from formulas */
                            next
                              case case_2
                              solve( State_121111111( init, ~n.3, signed, skV.1 ) ▶₀ #t2.5 )
                                case event_Voutput_aencshared_k_pkskV_signed_12111111
                                solve( !KU( ~n.6 ) @ #vk.4 )
                                  case out_aencshared_k_pkskV_repaencshared_k_pkskV_loc_pkskV__11111111_case_1
                                  solve( !KU( senc(<~n.1, 'input'>, ~n.6) ) @ #vk.5 )
                                    case csenc
                                    by contradiction /* from formulas */
                                  next
                                    case out_senc_ip_input_shared_k12111111111111111
                                    by contradiction /* from formulas */
                                  qed
                                next
                                  case out_aencshared_k_pkskV_repaencshared_k_pkskV_loc_pkskV__11111111_case_2
                                  solve( !KU( senc(<~n.1, 'input'>, ~n.6) ) @ #vk.5 )
                                    case csenc
                                    by contradiction /* from formulas */
                                  next
                                    case out_senc_ip_input_shared_k12111111111111111
                                    by contradiction /* from formulas */
                                  qed
                                qed
                              qed
                            qed
                          next
                            case case_2
                            by contradiction /* from formulas */
                          qed
                        qed
                      qed
                    qed
                  next
                    case case_2
                    solve( State_121111111( init, ~n.3, signed, skV.1 ) ▶₀ #t2.4 )
                      case event_Voutput_aencshared_k_pkskV_signed_12111111
                      solve( Unlock( ~lock10.1, ~n.5 ) @ #t2.5 )
                        case unlock_storeP111111111111111111
                        by solve( State_111111111111111111( ~lock10.1, init, ip, old_i.2,
                                                            shared_k, skV.1, ~n.5
                                  ) ▶₀ #t2.5 )
                      next
                        case unlock_storeV121111111111111111111
                        solve( State_121111111111111111111( ~lock10.1, init, ip, old_i.2,
                                                            shared_k, signed, skV.1, ~n.5
                               ) ▶₀ #t2.5 )
                          case insert_storeV_listip_old_i12111111111111111111
                          solve( (#t2.4 < #t2.7)  ∥ (#t2.4 = #t2.7) )
                            case case_1
                            by contradiction /* from formulas */
                          next
                            case case_2
                            solve( State_121111111( init, ~n.3, signed, skV.1 ) ▶₀ #t2.6 )
                              case event_Voutput_aencshared_k_pkskV_signed_12111111
                              solve( !KU( ~n.6 ) @ #vk.4 )
                                case out_aencshared_k_pkskV_repaencshared_k_pkskV_loc_pkskV__11111111_case_1
                                solve( !KU( senc(<~n.1, 'input'>, ~n.6) ) @ #vk.5 )
                                  case csenc
                                  by contradiction /* from formulas */
                                next
                                  case out_senc_ip_input_shared_k12111111111111111
                                  by contradiction /* from formulas */
                                qed
                              next
                                case out_aencshared_k_pkskV_repaencshared_k_pkskV_loc_pkskV__11111111_case_2
                                solve( !KU( senc(<~n.1, 'input'>, ~n.6) ) @ #vk.5 )
                                  case csenc
                                  by contradiction /* from formulas */
                                next
                                  case out_senc_ip_input_shared_k12111111111111111
                                  by contradiction /* from formulas */
                                qed
                              qed
                            qed
                          qed
                        qed
                      qed
                    qed
                  qed
                qed
              qed
            qed
          qed
        qed
      qed
    qed
  next
    case case_2
    solve( State_121111111( init, ~n.2, signed, skV ) ▶₀ #t2.1 )
      case event_Voutput_aencshared_k_pkskV_signed_12111111
      solve( State_121111111( init, ~n.2, signed, skV ) ▶₀ #t2.2 )
        case event_Voutput_aencshared_k_pkskV_signed_12111111
        solve( !KU( prog(~n.1, old_i.1) ) @ #t3 )
          case cprog
          by contradiction /* from formulas */
        next
          case out_senc_progip_old_i_output_shared_k1111111111111111
          solve( (#vr.36 < #t2.3)  ∥ (#vr.36 = #t2.3) )
            case case_1
            solve( Insert( ~n.4, old_i ) @ #t2.2 )
              case insert_storeV_init12111111111
              solve( !KU( ~n.5 ) @ #vk.4 )
                case out_aencshared_k_pkskV_repaencshared_k_pkskV_loc_pkskV__11111111_case_1
                solve( !KU( senc(<~n.1, 'input'>, ~n.5) ) @ #vk.5 )
                  case csenc
                  by contradiction /* from formulas */
                next
                  case out_senc_ip_input_shared_k12111111111111111
                  by contradiction /* from formulas */
                qed
              next
                case out_aencshared_k_pkskV_repaencshared_k_pkskV_loc_pkskV__11111111_case_2
                solve( !KU( senc(<~n.1, 'input'>, ~n.5) ) @ #vk.5 )
                  case csenc
                  by contradiction /* from formulas */
                next
                  case out_senc_ip_input_shared_k12111111111111111
                  by contradiction /* from formulas */
                qed
              qed
            qed
          next
            case case_2
            solve( Insert( ~n.4, old_i ) @ #t2.2 )
              case insert_storeV_init12111111111
              solve( !KU( ~n.5 ) @ #vk.4 )
                case out_aencshared_k_pkskV_repaencshared_k_pkskV_loc_pkskV__11111111_case_1
                solve( !KU( senc(<~n.1, 'input'>, ~n.5) ) @ #vk.5 )
                  case csenc
                  by contradiction /* from formulas */
                next
                  case out_senc_ip_input_shared_k12111111111111111
                  by contradiction /* from formulas */
                qed
              next
                case out_aencshared_k_pkskV_repaencshared_k_pkskV_loc_pkskV__11111111_case_2
                solve( !KU( senc(<~n.1, 'input'>, ~n.5) ) @ #vk.5 )
                  case csenc
                  by contradiction /* from formulas */
                next
                  case out_senc_ip_input_shared_k12111111111111111
                  by contradiction /* from formulas */
                qed
              qed
            qed
          qed
        qed
      qed
    qed
  qed
qed

lemma attested_computation:
  all-traces
  "∀ #t1 h.
    (Voutput( h ) @ #t1) ⇒ (∃ #t2. (Poutput( h ) @ #t2) ∧ (#t2 < #t1))"
/*
guarded formula characterizing all counter-examples:
"∃ #t1 h.
  (Voutput( h ) @ #t1) ∧ ∀ #t2. (Poutput( h ) @ #t2) ⇒ ¬(#t2 < #t1)"
*/
simplify
solve( Voutput( h ) @ #t1 )
  case event_Voutput_aencshared_k_pkskV_signed_12111111
  solve( State_12111111( init, shared_k, signed, skV ) ▶₀ #t1 )
    case if_eqaencshared_k_pkskV_check_repsigned_loc_pkskV__01211111
    by contradiction /* from formulas */
  qed
next
  case event_Voutputsenc_progip_old_i_output_shared_k1211111111111111111
  solve( State_1211111111111111111( ~lock10, init, ip, old_i, shared_k,
                                    signed, skV, storeV
         ) ▶₀ #t1 )
    case in_senc_progip_old_i_output_shared_k121111111111111111
    solve( (#vr.8 < #t2.1)  ∥ (#vr.8 = #t2.1) )
      case case_1
      solve( State_121111111( init, ~n.2, signed, skV ) ▶₀ #t2 )
        case event_Voutput_aencshared_k_pkskV_signed_12111111
        solve( !KU( senc(<prog(~n.1, old_i), 'output'>, ~n.2) ) @ #vk.2 )
          case csenc
          by contradiction /* from formulas */
        next
          case out_senc_progip_old_i_output_shared_k1111111111111111
          by contradiction /* from formulas */
        qed
      qed
    next
      case case_2
      solve( State_121111111( init, ~n.2, signed, skV ) ▶₀ #t2 )
        case event_Voutput_aencshared_k_pkskV_signed_12111111
        solve( !KU( senc(<prog(~n.1, old_i), 'output'>, ~n.2) ) @ #vk.2 )
          case csenc
          by contradiction /* from formulas */
        next
          case out_senc_progip_old_i_output_shared_k1111111111111111
          by contradiction /* from formulas */
        qed
      qed
    qed
  qed
qed

/*
WARNING: the following wellformedness checks failed!

unbound:
  rule `lookup_storeP_as_old_i_01111111111111' has unbound variables: 
    old_i
  
  rule `lookup_storeV_as_old_i_012111111111111' has unbound variables: 
    old_i
*/

end

==============================================================================
summary of summaries:

analyzed: SOC.spthy

  WARNING: 2 wellformedness check failed!
           The analysis results might be wrong!
  
  secrecy (all-traces): verified (5 steps)
  Input (all-traces): verified (38 steps)
  secrecy_computes2 (all-traces): verified (11 steps)
  secrecy_computes3 (all-traces): verified (127 steps)
  attested_computation (all-traces): verified (14 steps)

==============================================================================
